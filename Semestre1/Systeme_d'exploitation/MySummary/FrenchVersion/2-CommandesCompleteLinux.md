# Commandes Linux Avancées

**Remarque :** Ne soyez pas effrayé par le mot `Avancé`, car nous avons étudié ces commandes et opérateurs.
Incluant la gestion des processus dans TP5.

## 1. Commandes d'Information Utilisateur

- `whoami` - Afficher le nom d'utilisateur actuel

  ```bash
  $ whoami
  nom_utilisateur
  ```

- `groups` - Afficher les groupes auxquels l'utilisateur actuel appartient

  ```bash
  $ groups
  alice sudo docker networkmanager   # Montre tous les groupes pour l'utilisateur actuel
  ```

- `who` - Montrer qui est connecté

  ```bash
  $ who
  nom_utilisateur  tty1    2024-12-08 09:00
  utilisateur2     pts/0   2024-12-08 10:15
  ```

- `w` - Afficher des informations détaillées sur les utilisateurs connectés et ce qu'ils font

  ```bash
  $ w
  10:30:00 up 2 days, 3 users, load average: 0.52, 0.47, 0.43
  USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU  WHAT
  nom_utilisateur tty1     -                09:00    1:30   0.12s  0.05s nano file.txt
  utilisateur2    pts/0    192.168.1.100    10:15    2.00s  0.08s  0.02s top
  ```

- `users` - Afficher les noms d'utilisateurs connectés

  ```bash
  $ users
  nom_utilisateur utilisateur2 utilisateur3
  ```

- `id` - Afficher les informations sur l'utilisateur et les groupes
  ```bash
  $ id
  uid=1000(nom_utilisateur) gid=1000(nom_utilisateur) groups=1000(nom_utilisateur),4(adm),24(cdrom),27(sudo)
  ```

## 2. Opérateurs et Contrôle sous Linux

### Opérateurs de Base

- `&` - Exécuter en arrière-plan

  ```bash
  # Exécuter une commande en arrière-plan
  gedit monfichier.txt &
  # Vous pouvez continuer à utiliser le terminal
  ```

- `;` - Exécuter des commandes en séquence

  ```bash
  # Les commandes s'exécutent l'une après l'autre, même si la première échoue
  echo "Premier" ; echo "Deuxième"
  # Sortie :
  # Premier
  # Deuxième
  ```

- `&&` - Opérateur ET (exécuter la deuxième commande seulement si la première réussit)

  ```bash
  # Créer un répertoire ET y entrer
  mkdir nouveau_dossier && cd nouveau_dossier
  # La deuxième commande ne s'exécute que si la première a fonctionné
  ```

- `||` - Opérateur OU (exécuter la deuxième commande seulement si la première échoue)
  ```bash
  # Essayer de créer un répertoire, afficher une erreur s'il existe déjà
  mkdir dossier_existant || echo "Le dossier existe déjà !"
  ```

### Opérateurs de Redirection

- `>` - Rediriger la sortie (écrase le fichier)

  ```bash
  # Sauvegarder la sortie de ls dans un fichier (crée ou écrase)
  ls > fichiers.txt
  ```

- `>>` - Rediriger la sortie (ajouter au fichier)

  ```bash
  # Ajouter la sortie de ls à la fin du fichier
  ls >> fichiers.txt
  ```

- `2>` - Rediriger les erreurs

  ```bash
  # Masquer les messages d'erreur en les envoyant nulle part
  find / -name "*.txt" 2> /dev/null
  ```

- `|` - Pipe (envoyer la sortie de la première commande à la deuxième)

  ```bash
  # Compter le nombre de fichiers dans un répertoire
  ls | wc -l

  # Trouver des fichiers contenant "erreur"
  cat fichier_log.txt | grep "erreur"
  ```

## 3. Combinaisons Utiles

- Compter les fichiers dans un répertoire :
  ```bash
  ls | wc -l
  ```
- Rechercher du texte et compter les correspondances :
  ```bash
  grep "erreur" fichier_log.txt | wc -l
  ```

## 4. Gestion des Processus

### Commandes de Contrôle de Processus

- `Ctrl+C` (C-c) - Arrêter le processus actuel

  ```bash
  # Quand une commande prend trop de temps ou est bloquée
  commande_longue
  # Appuyez sur Ctrl+C pour l'arrêter
  ```

- `Ctrl+Z` (C-z) - Mettre en pause le processus actuel et le placer en arrière-plan

  ```bash
  # Démarrer une commande
  sleep 300
  # Appuyez sur Ctrl+Z pour mettre en pause
  # [1]+ Stopped sleep 300
  ```

- `Ctrl+D` (C-d) - Envoyer EOF (Fin de Fichier)
  ```bash
  # Généralement utilisé pour quitter le terminal ou terminer une entrée
  cat > fichier.txt
  bonjour monde
  [Ctrl+D]  # Termine l'entrée
  ```

### Commandes de Gestion des Processus

- `jobs` - Lister les processus en arrière-plan

  ```bash
  $ gedit & nano & # Démarrer gedit et nano en arrière-plan
  $ jobs # Lister les tâches en arrière-plan
  [1] Running gedit &
  [2] Stopped nano

  $ jobs -l # Lister les tâches en arrière-plan avec PIDs
  [1] 12345 Running gedit &
  [2] 12346 Stopped nano
  ```

- `bg` - Reprendre un processus arrêté en arrière-plan

  ```bash
  $ sleep 300
  [Ctrl+Z]  # Arrête nano
  $ bg      # Reprend sleep en arrière-plan
  ```

- `fg` - Ramener un processus d'arrière-plan au premier plan

  ```bash
  $ jobs
  [1] Running    gedit &
  $ fg 1    # Ramène gedit au premier plan
  ```

- `ps` - Afficher les processus

  ```bash
  $ ps
  PID TTY          TIME CMD
  1234 pts/0    00:00:00 bash
  5678 pts/0    00:00:00 ps
  ```

- `kill` - Arrêter un processus

  ```bash
  # utilisez `jobs -l` ou `ps` pour trouver l'ID de processus (PID)

  # Arrêter par ID de processus (PID)
  kill 1234

  # Forcer l'arrêt (quand le processus ne s'arrête pas)
  kill -9 1234
  ```

- `top` ou `htop` ou `gtop` - Afficher les informations de processus en temps réel

  ```bash
  # Montre les processus en cours, l'utilisation du CPU, la mémoire
  # Appuyez sur 'q' pour quitter
  $ top
  Tâches : 100 au total,   1 en cours,  99 en veille...
  ```

### Scénarios Courants de Contrôle de Processus

1. Quand une commande est bloquée :

   ```bash
   $ commande_longue
   [Ctrl+C]  # Arrête la commande
   ```

2. Exécuter plusieurs commandes :

   ```bash
   # Commandes dépendant du succès
   mkdir test && cd test && touch fichier.txt

   # Commandes indépendantes
   echo "Premier" ; echo "Deuxième" ; echo "Troisième"
   ```

3. Workflow de processus en arrière-plan :
   ```bash
   $ gedit fichier.txt &   # Démarrer en arrière-plan
   $ jobs              # Vérifier les tâches en cours
   $ fg                # Ramener au premier plan
   [Ctrl+Z]           # Mettre en pause
   $ bg                # Reprendre en arrière-plan
   ```

### Conseils pour le Contrôle des Processus :

1. Utilisez `ps` pour vérifier un processus ou l'ID de la tâche
2. Utilisez `kill` pour arrêter le processus (`kill %ID_tâche` ou `kill PID`)

## 5. Liens de Fichiers sous Linux

#### Types de Liens

- **Liens Symboliques (Liens Souples)**

  ```bash
  ln -s cible nom_lien   # Créer un lien symbolique
  ```

  - Peut lier des fichiers ou des répertoires.
  - Fonctionne à travers les systèmes de fichiers.
  - Se brise si la cible est supprimée.

- **Liens Physiques (Liens Durs)**
  ```bash
  ln cible nom_lien   # Créer un lien physique
  ```
  - Fonctionne uniquement avec les fichiers (pas les répertoires).
  - Doit être sur le même système de fichiers.
  - Reste fonctionnel si l'original est supprimé.

#### Différences

| Caractéristique                  | Liens Symboliques     | Liens Physiques      |
| -------------------------------- | --------------------- | -------------------- |
| Type de lien                     | Pointe vers le chemin | Pointe vers l'inode  |
| Types de cible                   | Fichiers, répertoires | Fichiers uniquement  |
| Traversée de système de fichiers | Autorisée             | Non autorisée        |
| Cible supprimée                  | Devient cassé         | Toujours fonctionnel |

#### Exemples

1. **Créer un Lien Symbolique**

   ```bash
   ln -s /chemin/vers/fichier mon_lien
   ln -s /chemin/vers/dossier mon_lien_dossier
   ```

2. **Créer un Lien Physique**

   ```bash
   ln fichier.txt lien_physique.txt
   ```

3. **Supprimer un Lien**

   ```bash
   rm nom_lien
   ```

4. **Vérifier si un Fichier est un Lien**
   ```bash
   ls -l nom_fichier  # Montre `->` pour les liens symboliques
   ls -i fichier.txt lien_physique.txt  # Même inode pour les liens physiques
   ```
