# Advanced linux commands

**Note:** do note be afraid of the word `Advanced` as we did study these commmands and operators.
Including process Management in TP5.

## 1. User Information Commands

- `whoami` - Display current username

  ```bash
  $ whoami
  username
  ```

- `groups` - Display groups the current user belongs to

  ```bash
  $ groups
  alice sudo docker networkmanager   # Shows all groups for current user
  ```

- `who` - Show who is logged in

  ```bash
  $ who
  username  tty1    2024-12-08 09:00
  user2     pts/0   2024-12-08 10:15
  ```

- `w` - Show detailed information about logged-in users and what they're doing

  ```bash
  $ w
  10:30:00 up 2 days, 3 users, load average: 0.52, 0.47, 0.43
  USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU  WHAT
  username tty1     -                09:00    1:30   0.12s  0.05s nano file.txt
  user2    pts/0    192.168.1.100    10:15    2.00s  0.08s  0.02s top
  ```

- `users` - Display usernames of logged-in users

  ```bash
  $ users
  username user2 user3
  ```

- `id` - Display user and group information
  ```bash
  $ id
  uid=1000(username) gid=1000(username) groups=1000(username),4(adm),24(cdrom),27(sudo)
  ```

## 2. Operators and Control in Linux

### Basic Operators

- `&` - Run in background

  ```bash
  # Running a command in background
  gedit myfile.txt &
  # You can continue using the terminal while gedit runs
  ```

- `;` - Run commands in sequence

  ```bash
  # Commands run one after another, even if first fails
  echo "First" ; echo "Second"
  # Output:
  # First
  # Second
  ```

- `&&` - AND operator (run second command only if first succeeds)

  ```bash
  # Create directory AND enter it
  mkdir new_folder && cd new_folder
  # Second command runs only if first one worked
  ```

- `||` - OR operator (run second command only if first fails)
  ```bash
  # Try to create directory, print error if it fails
  mkdir existing_folder || echo "Folder already exists!"
  ```

### Redirection Operators

- `>` - Redirect output (overwrites file)

  ```bash
  # Save ls output to file (creates new or overwrites existing)
  ls > files.txt
  ```

- `>>` - Redirect output (append to file)

  ```bash
  # Add ls output to end of file
  ls >> files.txt
  ```

- `2>` - Redirect errors

  ```bash
  # Hide error messages by sending them to nowhere
  find / -name "*.txt" 2> /dev/null
  ```

- `|` - Pipe (send output of first command to second command)

  ```bash
  # Count how many files are in directory
  ls | wc -l

  # Find files containing "error"
  cat logfile.txt | grep "error"
  ```

## 3. Useful Combinations

- Count files in directory:
  ```bash
  ls | wc -l
  ```
- Search for text and count matches:
  ```bash
  grep "error" logfile.txt | wc -l
  ```

## 4. Process Management

### Process Control Commands

- `Ctrl+C` (C-c) - Stop current process

  ```bash
  # When a command is running too long or stuck
  long_running_command
  # Press Ctrl+C to stop it
  ```

- `Ctrl+Z` (C-z) - Pause current process and put in background

  ```bash
  # Start a command
  sleep 300
  # Press Ctrl+Z to pause it
  # [1]+ Stopped sleep 300
  ```

- `Ctrl+D` (C-d) - Send EOF (End Of File)
  ```bash
  # Usually used to exit terminal or end input
  cat > file.txt
  hello world
  [Ctrl+D]  # Ends input
  ```

### Process Management Commands

- `jobs` - List background processes

  ```bash
  $ gedit & nano & # Start gedit and nano in the background
  $ jobs # List background jobs
  [1] Running gedit &
  [2] Stopped nano

  $ jobs -l # List background jobs with PIDs
  [1] 12345 Running gedit &
  [2] 12346 Stopped nano
  ```

- `bg` - Resume stopped process in background

  ```bash
  $ sleep 300
  [Ctrl+Z]  # Stops nano
  $ bg      # Resumes sleep in background
  ```

- `fg` - Bring background process to foreground

  ```bash
  $ jobs
  [1] Running    gedit &
  $ fg 1    # Brings gedit to foreground
  ```

- `ps` - Show processes

  ```bash
  $ ps
  PID TTY          TIME CMD
  1234 pts/0    00:00:00 bash
  5678 pts/0    00:00:00 ps
  ```

- `kill` - Stop a process

  ```bash
  # use `jobs -l` or `ps` to find the process ID (PID)

  # Kill by process ID (PID)
  kill 1234

  # Force kill (when process won't stop)
  kill -9 1234
  ```

- `top` or `htop` or `gtop` - Show real-time process information

  ```bash
  # Shows running processes, CPU usage, memory usage
  # Press 'q' to exit
  $ top
  Tasks: 100 total,   1 running,  99 sleeping...
  ```

### Common Process Control Scenarios

1. When a command is stuck:

   ```bash
   $ long_running_command
   [Ctrl+C]  # Stops the command
   ```

2. Running multiple commands:

   ```bash
   # Success dependent commands
   mkdir test && cd test && touch file.txt

   # Independent commands
   echo "First" ; echo "Second" ; echo "Third"
   ```

3. Background process workflow:
   ```bash
   $ gedit file.txt &   # Start in background
   $ jobs              # Check running jobs
   $ fg                # Bring back to foreground
   [Ctrl+Z]           # Pause it
   $ bg                # Resume in background
   ```

### Tips for Process Control:

1. Use `ps` to check a process or job PID
2. Use `kill` to kill the process (`kill %jobID` or `kill PID`)

## 5. File Links in Linux

#### Types of Links

- **Symbolic Links (Soft Links)**

  ```bash
  ln -s target link_name   # Create a symbolic link
  ```

  - Can link files or directories.
  - Works across filesystems.
  - Breaks if the target is deleted.

- **Hard Links**
  ```bash
  ln target link_name   # Create a hard link
  ```
  - Works only with files (not directories).
  - Must be on the same filesystem.
  - Remains functional if the original is deleted.

#### Differences

| Feature             | Symbolic Links     | Hard Links          |
| ------------------- | ------------------ | ------------------- |
| Link type           | Points to the path | Points to the inode |
| Target types        | Files, directories | Files only          |
| Filesystem crossing | Allowed            | Not allowed         |
| Target deleted      | Becomes broken     | Still functional    |

#### Examples

1. **Create Symbolic Link**

   ```bash
   ln -s /path/to/file mylink
   ln -s /path/to/dir mydirlink
   ```

2. **Create Hard Link**

   ```bash
   ln file.txt hardlink.txt
   ```

3. **Remove a Link**

   ```bash
   rm link_name
   ```

4. **Check if a File is a Link**
   ```bash
   ls -l filename  # Shows `->` for symbolic links
   ls -i file.txt hardlink.txt  # Same inode for hard links
   ```
